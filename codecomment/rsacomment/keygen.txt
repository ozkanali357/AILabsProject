'''
This file aims to generate public and private keys for RSA encryption and decryption.
'''

import sys
import os
from math import gcd
from pathlib import Path

PROJECT_ROOT = Path(__file__).resolve().parents[2]
sys.path.insert(0, str(PROJECT_ROOT))

# We use the large prime numbers generated by prime_gen.py.
from projectcode.rsa.primegen import dobigprime

# The integer bits is 1024 which is the default key size
# for the key generation done with prime numbers.
def genkeys(bits=1024):
    """
    This function generates the public and private keys for RSA encryption and decryption.
    """
# e should be 1 < e < phi and gcd(e, phi) = 1 (phi is explained below).
# e is the public exponent. 65537 is a common choice for e,
# because it is a prime number and it has properties that make the encryption faster.
    e = 65537
# The difference being small in the prime numbers generated reduces security.
# If it's closer, the modulus ( n = p \times q ) can be factored easily.
    difference = 2**(bits // 2 - 100)

    while True:
# Two large prime numbers are generated.
        p = dobigprime(bits)
        q = dobigprime(bits)
# It checks to be sure that p and q are not equal.
# It also checks that the difference is greater than 2^(412)
        if p == q or abs(p - q) < difference:
            continue

# n is the modulus for the public and private keys.
# The security of the RSA algorithm depends on the fact that it is difficult to factorize
# the modulus n to its components p and q.
        n = p * q
# phi is Euler's totient function (the totient of n).
# It symbolises the number of integers up to n that are coprime
# (two numbers having only 1 as their common factor) with n.
# The totient function is used to calculate the public and private exponents.
# Therefore, it mathematically links the encryption and decryption processes.
        phi = (p - 1) * (q - 1)

# We need to make sure that e is coprime with phi.
        if gcd(e, phi) != 1:
            e = 3
            while gcd(e, phi) != 1:
                e += 2
        try:
# d is the private exponent.
# We compute it as the modular multiplicate inverse of e modulo phi. (d * e) % phi = 1
# The pow function with three arguments computes this accurately.
            d = pow(e, -1, phi)
        except ValueError:
            continue

        break

    pubkey = (e, n)
    privkey = (d, n)
# It returns a tuple having the public key, the private key, the primes p and q.
    return pubkey, privkey, p, q
